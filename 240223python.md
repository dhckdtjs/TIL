# 비트 연산
### AND와 OR 비트연산자 이해하기
* a AND b : a,b 둘 다 1일때만 결과가 1이다. 그외에는 0
* a OR b : a,b 둘 다 0일때만 결과가 1이다. 그외에는 1
### 비트 연산자
* & : 비트단위로 AND 연산을 한다.
  * 예) num1&num2
* | : 비트단위로 OR 연산을 한다.
  * 예) num1|num2
* ^ : 비트단위로 XOR연산을 한다. (같으면 0 다르면 1)
  * 예) num1^num2
* ~ : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.
  * 예) ~num
* << : 피연산자의 비트열을 왼쪽으로 이동시킨다.
  * 예) num<<2
* '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
  * 예) num>>2
### 1<<n
* 2^n의 값을 갖는다.
* 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.
* 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
* Power set(모든 부분 집합)
### i&(1<<j)
* 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.
```py
def Bbit_print(i):
    output = ""
    for j in range(7,-1,-1):
        output = "1" if i & (1<<j) else "0"
        print(output)
for i in range(-5,6):
    print("%3d = "%i,end='')
    Bbit_print(i)
# MSB : 1 -> 음수
# MSB : 0 -> 양수
```
### 2의 보수 예시
* 10001의 2의 보수
* -> 수를 모두 뒤집고 +1을 한다.
* 01110+1=01111

* 1111000의 2의 보수
* -> 수를 뒤집으면 0000111이고 +1을 한다.
* -> 0000111+1=0001000
### -5를 2의 보수로 표현하는 방법 (가정: 수를 8bit로 저장하는 경우)
* 수 5를 2진수로 나타내면 000 0101이다.(7bit)
* -5는 음수이기에 MSB는 1
* 나머지 7bit에 대해, 수를 뒤집고 1을 더하면 된다.(2의 보수)
* 수 5를 뒤집으면 111 1010이며, 1을 더하면 111 1011이 된다.
* 따라서 1111 1011이 된다.
### NOT 연산자
* (~)NOT 연산자 : 모든 비트를 반전시킨다.
* 만약 8 bit일 때 ~(0001 1111)이라면 값은 1110 0000이 된다.
### NOT 연산자를 파이썬에서 수행하기
* 파이썬에서는 ~4를 수행하면 -5가 출력된다.
### 파이썬이 ~4를 -5로 출력하는 과정
* 4는 0b0100이다.(MSB:양수이므로 0)
* NOT 연산자로 인해 뒤집으면 1011이 된다.
* MSB는 1이 되었고(음수), 나머지 bit는 011이다.
* 나머지 bit에 대해 2의 보수를 취하면 100+1=101이므로 5가 된다.
* 따라서 -5가 된다.
